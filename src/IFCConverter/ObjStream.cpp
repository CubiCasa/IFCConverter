#include "../IFCConverter/ObjStream.h"


ObjStream::ObjStream(const std::string name):
Stream(name)
{

	std::string geometryFileName = name + std::string(".obj");
	std::string materialFileName = name + std::string(".mtl");
	//Open geometry and material stream.
	geometryStream.open(geometryFileName, std::ofstream::out);
	materialStream.open(materialFileName, std::ofstream::out);

	//Write header
	geometryStream << "# File generated by IFCConverter" << std::endl;
	geometryStream << "mtllib " << parseFileName(materialFileName) << std::endl;
	materialStream << "# File generated by IFCConverter" << std::endl;
}

ObjStream::~ObjStream()
{
	close();
}

void ObjStream::close()
{
	geometryStream.close();
	materialStream.close();
}

void ObjStream::writeMesh(const std::string& meshName, const std::vector<double>& vertices, const std::vector<double>& normals, const std::vector<int>& indices, const std::vector<IfcGeom::Material>& materials)
{

	std::string materialName;

	if (!materials.empty())
	{
		//There should be only one material per mesh, so process only the first element.
		const IfcGeom::Material& material = materials[0];
		ObjMaterial newObjMaterial(material);

		auto objMaterial = std::find(std::begin(createdMaterials), std::end(createdMaterials), newObjMaterial);
		if (objMaterial == std::end(createdMaterials))
		{
			materialName = newObjMaterial.name;
			materialStream << "newmtl " << newObjMaterial.name << std::endl;
			if (material.hasDiffuse())
			{
				materialStream << "Kd " << newObjMaterial.Kd.r << " " << newObjMaterial.Kd.g << " " << newObjMaterial.Kd.b << std::endl;
			}
			if (material.hasSpecular())
			{
				materialStream << "Ks " << newObjMaterial.Ks.r << " " << newObjMaterial.Ks.g << " " << newObjMaterial.Ks.b << std::endl;
			}
			if (material.hasSpecularity())
			{
				materialStream << "Ns " << newObjMaterial.Ns << std::endl;
			}
			if (material.hasTransparency())
			{
				materialStream << "d " << newObjMaterial.Tr << std::endl;
			}
			createdMaterials.push_back(newObjMaterial);
		}
		else
		{
			materialName = objMaterial->name;
		}
	}
	
	geometryStream << "o " << meshName << std::endl;

	for (unsigned int i = 0; i < vertices.size() / 3; ++i)
	{
		geometryStream << "v " << vertices[i * 3] << " " << vertices[i * 3 + 1] << " " << vertices[i * 3 + 2] << std::endl;
	}

	for (unsigned int i = 0; i < normals.size() / 3; ++i)
	{
		geometryStream << "vn " << normals[i * 3] << " " << normals[i * 3 + 1] << " " << normals[i * 3 + 2] << std::endl;
	}

	geometryStream << "usemtl " << materialName << std::endl;
	geometryStream << "s 1" << std::endl;

	for (unsigned int i = 0; i < indices.size() / 3; ++i)
	{
		const int v1 = indices[i * 3] + vertexCount;
		const int v2 = indices[i * 3 + 1] + vertexCount;
		const int v3 = indices[i * 3 + 2] + vertexCount;
		//Vertex Normal Indices Without Texture Coordinate Indices.		
		geometryStream << "f " << v1 << "//" << v1 << " " << v2 << "//" << v2 << " " << v3 << "//" << v3 << std::endl;
		//geometryStream << "f " << v1 << "/" << v1 << "/" << v1 << " " << v2 << "/" << v2 << "/" << v2 << " " << v3 << "/" << v3 << "/" << v3 << "\n";
	}

	vertexCount += (vertices.size() / 3);
}